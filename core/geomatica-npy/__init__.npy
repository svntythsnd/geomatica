from typing import Callable as _Callable, Union as _Union, overload as _overload;
from abc import ABC as _ABC, abstractmethod as _absd;

class IMultivector(_ABC) {
    @property; @_absd; := algebra(self) >: 'GA' { """a reference to the Multivector's parent GA.""" }
    @_absd; := __add__(self, other: _Union[int, float, 'IMultivector']) >: 'IMultivector' {}
    @_absd; := __radd__(self, other: _Union[int, float, 'IMultivector']) >: 'IMultivector' {}
    @_absd; := __sub__(self, other: _Union[int, float, 'IMultivector']) >: 'IMultivector' {}
    @_absd; := __rsub__(self, other: _Union[int, float, 'IMultivector']) >: 'IMultivector' {}
    @_absd; := __neg__(self) >: 'IMultivector' {}
    @_absd; := __invert__(self) >: 'IMultivector' { """Return the adjugate of the Multivector.""" }
    @_absd; := __mul__(self, other: _Union[int, float, 'IMultivector']) >: 'IMultivector' { """Compute e^M either by decomposing the Multivector into commuting blocks or, if that fails, explicit Taylor expansion.""" }
    @_absd; := __rmul__(self, other: int | float) >: 'IMultivector' {}
    @_absd; := __pow__(self, other: int | float) >: 'IMultivector' {}
    @_absd; := __rpow__(self, other: int | float) >: 'IMultivector' { """Exponentiate the Multivector by applying e^(M ln b).""" }
    @_absd; := __abs__(self) >: float { """Return the determinant of the Multivector.""" }
    @_absd; := __matmul__(self, grade: int) >: 'IMultivector' { """Extract a specific grade of the Multivector.""" }
    @_absd; := __truediv__(self, other: _Union[int, float, 'IMultivector']) >: 'IMultivector' {}
    @_absd; := __rtruediv__(self, other: int | float) >: 'IMultivector' {}
    @_absd; := __or__(self, other: _Union[int, float, 'IMultivector']) >: 'IMultivector' { """Return the Perwass dot product of two Multivectors.""" }
    @_absd; := __ror__(self, other: int | float) >: 'IMultivector' { """Return the Perwass dot product of two Multivectors.""" }
    @_absd; := __xor__(self, other: _Union[int, float, 'IMultivector']) >: 'IMultivector' { """Return the wedge product of two Multivectors.""" }
    @_absd; := __rxor__(self, other: int | float) >: 'IMultivector' { """Return the wedge product of two Multivectors.""" }
    @_absd; := __pos__(self) >: int | None { """Return the grade of the Multivector if it's a blade, None otherwise.""" }
    @_absd; := __format__(self, form: str) >: str {}
    @_absd; := __str__(self) >: str {}
    @_absd; := exp(self) >: 'IMultivector' {}
}

class NoAdjugateError(ValueError) { """Raised when a Multivector does not admit an adjugate.""" }
class GAMismatchError(TypeError) { """Raised when two Multivectors from different GA instances are combined.""" }

_subscripts = str.maketrans('0123456789','₀₁₂₃₄₅₆₇₈₉');

:= _merge_sort_parity(arr) {
    if len(arr) <= 1 :=> arr, 1;

    mid = len(arr) ~/ 2;
    left, p_left = _merge_sort_parity(arr[:mid]);
    right, p_right = _merge_sort_parity(arr[mid:]);

    merged = [];
    parity = p_left * p_right;

    i = j = 0;
    while i < len(left) && j < len(right) {
        if left[i] <= right[j] {
            merged.append(left[i]);
            i += 1;
            continue
        }
        merged.append(right[j]);
        j += 1;
        if (len(left) - i) & 1: parity = -parity
    }

    merged.extend(left[i:]);
    merged.extend(right[j:]);

    => merged, parity
}


class GA {
    """
    A container representing a Geometric Algebra.

    Attributes:
        signature: a Callable returning the square of the nth basis vector.
        epsilon_order: integer offset for machine epsilon comparisons.
                       The effective bound for treating numbers as zero is
                       2^epsilon_order times the machine epsilon.
    """;
    __slots__ = ('signature', 'epsilon_order', '__Multivector');
    signature: _Callable[[int], float];
    epsilon_order: int;
    := __init__(ga, *, signature:_Callable[[int], float]=;=x:1.0, epsilon_order:int=0) {
        """
        Create a Geometric Algebra.

        Args:
            signature: a Callable returning the square of the nth basis vector.
                       Defaults to 1 for all.
            epsilon_order: integer offset for machine epsilon comparisons.
                       The effective bound for treating numbers as zero is
                       2^-epsilon_order times the machine epsilon. Defaults to 0.
        """;
        ga.signature = signature;
        ga.epsilon_order = epsilon_order;

        class Multivector(IMultivector) {
            @property;
            := algebra(self) >: GA :=> ga;

            __slots__ = ('__d', '__decomposition', '__sigma');

            := __init__(self, keys:dict[int, float], **argv) >: None {
                from math import ldexp;
                self.__d = -{k:v for k, v -> keys.items() if 1+abs(ldexp(v,-self.algebra.epsilon_order)) != 1}-;
                self.__decomposition = argv.get("decomposition", ...);
                self.__sigma = argv.get("sigma", ...)
            }

            := __add__(self, other: _Union[int, float, 'Multivector']) >: 'Multivector' {
                if isinstance(other, int | float) :=> Multivector(-{0: self.__d.get(0, 0) + other,
                                                        **-{mask: value for mask, value -> self.__d.items() if mask != 0}-}-,
                                                        decomposition=self.__decomposition, sigma=self.__sigma);
                if !isinstance(other, Multivector) {
                    if isinstance(other, IMultivector): raise GAMismatchError("Cannot combine Multivectors from different GA instances");
                    => NotImplemented
                }
                => Multivector(-{mask: self.__d.get(mask, 0) + other._Multivector__d.get(mask, 0) for mask -> sorted(self.__d.keys() | other._Multivector__d.keys())}-)
            }

            := __radd__(self, other: _Union[int, float, 'Multivector']) >: 'Multivector' :=> self+other;

            := __sub__(self, other: _Union[int, float, 'Multivector']) >: 'Multivector' :=> self+(-other);

            := __rsub__(self,other: _Union[int, float, 'Multivector']) >: 'Multivector':=> -self+other;

            := __neg__(self) >: 'Multivector' :=> Multivector(-{mask: -val for mask, val -> self.__d.items()}-, decomposition=self.__decomposition);

            := __invert__(self) >: 'Multivector' {
                sigma = self.__get_sigma();
                => Multivector(-{k: -v if (sigma >> n)&1 else v for n, (k, v) -> enumerate(self.__d.items())}-,
                            decomposition=self.__decomposition)
            }

            := __rmul__(self, other: int | float) >: 'Multivector' {
                if isinstance(other, int | float) :=> self*other;
                => NotImplemented
            }

            := __pow__(self, other: int | float) >: 'Multivector' {
                if !isinstance(other, int | float) :=> NotImplemented;
                from math import ldexp;
                if 1 + abs(ldexp(other % 1, -self.algebra.epsilon_order)) != 1: raise ValueError(f'Multivector exponent must be an integer, but got {other}');
                other = int(round(other));
                if other == 0 :=> self.algebra[0];
                if other < 0 {
                    if det <- abs(self): out = (~self)/det;
                    else: raise ZeroDivisionError(f"Cannot invert {self}: determinant is zero")
                } else: out = self;
                for _ -> range(abs(other)-1): out *= self;
                => out
            }

            := __abs__(self) >: float :=> (self*~self)._Multivector__d.get(0, 0);

            := __get_sigma(self) {
                if self.__sigma =& None: raise NoAdjugateError(f'Adjugate undefined for {self}');
                if self.__sigma !=& ... :=> self.__sigma;
                blades = list(self.__d.keys());
                if len(blades) == 0 {
                    self.__sigma = 0;
                    => 0
                } if added <- blades[0] != 0: blades = [0] + blades;
                from collections import deque;

                n = len(blades);

                epsilon = [[0]*n for _ -> range(n)];
                for i -> range(n) {
                    for j -> range(n) {
                        t = (blades[i] & blades[j]).bit_count();
                        parity = (blades[i].bit_count()*blades[j].bit_count() - t) & 1;
                        epsilon[i][j] = -1 if parity else +1
                    }
                }

                sigma = 0;
                known = 1;

                queue = deque([0]);

                while queue {
                    i = queue.popleft();
                    si = -1 if (sigma >> i) & 1 else +1;

                    for j -> range(n) {
                        if i == j: continue;

                        required_sign = -epsilon[i][j] * si;
                        required_bit = 1 if required_sign == -1 else 0;

                        mask = 1 << j;

                        if !(known & mask) {
                            if required_bit: sigma |= mask;
                            else: sigma &= ~mask;

                            known |= mask;
                            queue.append(j);
                            continue
                        }

                        current_bit = (sigma >> j) & 1;
                        if current_bit != required_bit {
                            if +(self*(2*self@0-self)) == 0 {
                                self.__sigma = sum(1 << n for n, b -> enumerate(blades) if b != 0);
                                if added: self.__sigma >>= 1;
                                => self.__sigma
                            } self.__sigma = None;
                            raise NoAdjugateError(f'Adjugate undefined for {self}')
                        }
                    }
                } => sigma >> 1 if added else sigma
            }

            := __rpow__(self, other: int | float) >: 'Multivector' {
                if !isinstance(other, int | float) :=> NotImplemented;
                import math;
                => (math.log(other)*self).exp()
            }

            := __mulbases(self, mask1, mask2) {
                if mask1 == 0 :=> mask2, 1;
                if mask2 == 0 :=> mask1, 1;
                if mask1 == mask2 {
                    init = -1 if mask1.bit_count() % 4 >= 2 else 1;
                    for n -> range(mask1.bit_length()) {
                        if (mask1 >> n) & 1: init *= self.algebra.signature(n+1)
                    } => 0, init
                }
                val = 1;
                bases = [i for i -> range(mask1.bit_length()) if (mask1 >> i) & 1] + [i for i -> range(mask2.bit_length()) if (mask2 >> i) & 1];
                seen = set();
                for basis -> tuple(bases) {
                    if basis -> seen: continue;
                    seen.add(basis);
                    diff = 0;
                    keep = False;
                    for n, factor -> enumerate(reversed(tuple(bases))) {
                        if factor != basis: continue;
                        keep = !keep;
                        if keep {
                            diff = n;
                            continue;
                        }
                        if n % 2 == diff % 2: val *= -1;
                        bases.pop(~diff);
                        bases.pop(~n+1 if n>diff else ~n);
                        val *= self.algebra.signature(basis+1);
                    }
                }

                bases, parity = _merge_sort_parity(bases);
                bases = sum(1 << i for i -> bases);

                => bases, val*parity
            }

            := __or__(self, other: _Union[int, float, 'Multivector']) >: 'Multivector' {
                if isinstance(other, int | float) :=> self*other;
                if !isinstance(other, Multivector) {
                    if isinstance(other, IMultivector): raise GAMismatchError("Cannot combine Multivectors from different GA instances");
                    => NotImplemented
                }
                new = -{}-;
                for mask1, val1 -> self.__d.items() {
                    for mask2, val2 -> other._Multivector__d.items() {
                        if (mask1^mask2).bit_count() != abs(mask1.bit_count() - mask2.bit_count()): continue;
                        mask, basisprod = self.__mulbases(mask1, mask2);
                        new[mask] = new.get(mask, 0) + val1*val2*basisprod
                    }
                } => Multivector(dict(sorted(new.items())))
            }

            := __ror__(self, other: int | float) >: 'Multivector' {
                if !isinstance(other, int | float) :=> NotImplemented;
                => self*other
            }

            := __xor__(self, other: _Union[int, float, 'Multivector']) >: 'Multivector' {
                if isinstance(other, int | float) :=> self.algebra[-1];
                if !isinstance(other, Multivector) {
                    if isinstance(other, IMultivector): raise GAMismatchError("Cannot combine Multivectors from different GA instances");
                    => NotImplemented
                }
                new = -{}-;
                for mask1, val1 -> self.__d.items() {
                    for mask2, val2 -> other._Multivector__d.items() {
                        if (mask1^mask2).bit_count() != mask1.bit_count() + mask2.bit_count(): continue;
                        mask, basisprod = self.__mulbases(mask1, mask2);
                        new[mask] = new.get(mask, 0) + val1*val2*basisprod
                    }
                } => Multivector(dict(sorted(new.items())))
            }

            := __rxor__(self, other: int | float) >: 'Multivector' {
                if !isinstance(other, int | float) :=> NotImplemented;
                => self.algebra[-1]
            }

            := __mul__(self, other: _Union[int, float, 'Multivector']) >: 'Multivector' {
                from math import ldexp;
                if isinstance(other, int | float) :=> Multivector(-{mask: other*val for mask, val -> self.__d.items()}-,
                        decomposition=self.__decomposition, sigma=self.__sigma)
                        if 1+abs(ldexp(other, -self.algebra.epsilon_order)) != 1
                        else Multivector(-{}-);
                elif !isinstance(other, Multivector) {
                    if isinstance(other, IMultivector): raise GAMismatchError("Cannot combine Multivectors from different GA instances");
                    => NotImplemented
                }
                new = -{}-;
                for mask1, val1 -> self.__d.items() {
                    for mask2, val2 -> other._Multivector__d.items() {
                        mask, basisprod = self.__mulbases(mask1, mask2);
                        new[mask] = new.get(mask, 0) + val1*val2*basisprod
                    }
                } => Multivector(dict(sorted(new.items())))
            }

            := __matmul__(self, grade: int) >: 'Multivector' {
                if !isinstance(grade, int) :=> NotImplemented;
                => Multivector(-{mask: val for mask, val -> self.__d.items() if mask.bit_count() == grade}-)
            }

            := __decompose(self) {
                if self.__decomposition !=& ... :=> self.__decomposition;
                commutes =;= mask1,mask2: mask1.bit_count()*mask2.bit_count()%2 == (mask1&mask2).bit_count()%2;
                blocks = [];
                for mask -> self.__d.keys() {
                    noncom = 0;
                    noncomindex = None;
                    for n, block -> enumerate(blocks) {
                        comtrack = None;
                        for item -> block {
                            if comtrack =& None {
                                comtrack = commutes(mask, item);
                                continue
                            }

                            if comtrack !=& commutes(mask, item) {
                                if +(self*self) == 0 {
                                    self.__decomposition = NotImplemented;
                                    => NotImplemented
                                }
                                self.__decomposition = None;
                                => None
                            }
                        }
                        if comtrack =& False {
                            noncomindex = n;
                            noncom++
                        }
                    }
                    if noncom == 0: blocks.append([mask]);
                    elif noncom == 1: blocks[noncomindex].append(mask);
                    else {
                        self.__decomposition = None;
                        => None
                    }
                }

                self.__decomposition = blocks;
                => blocks
            }

            := exp(self) >: 'Multivector' {
                d = self.__decompose();
                if d =& None {
                    from math import ldexp;
                    current = self;
                    cumulus = self.algebra[0] + current;
                    n = 2;
                    ~{
                        current *= self;
                        current /= n;
                        if 1+abs(ldexp(sum(s*s for s -> current.__d.values()),-self.algebra.epsilon_order)) == 1: break;
                        cumulus += current;
                        n++
                    }
                    => cumulus
                }
                import math;
                if d =& NotImplemented {
                    if (s <- (self|self).__d.get(0,0)) != 0: value = math.sqrt(abs(s));
                    => self.algebra[0]*math.cosh(value) + self*math.sinh(value)/value if s > 0
                       else self.algebra[0] + self if s == 0
                       else self.algebra[0]*math.cos(value) + self*math.sin(value)/value
                }
                prod = 1.0;
                for block -> d {
                    if block == [0] {
                        prod *= math.exp(self.__d[0]);
                        continue
                    }

                    total = 0;
                    for mask -> block {
                        norm = -1 if mask.bit_count() % 4 >= 2 else 1;
                        for i -> range(mask.bit_length()) {
                            if (mask >> i) & 1: norm *= self.algebra.signature(i+1);
                        } total += norm * self.__d[mask]**2
                    }

                    if total != 0: value = math.sqrt(abs(total));

                    prod *= Multivector(-{0: math.cosh(value), **-{mask:math.sinh(value)*self.__d[mask]/value for mask -> block}-}-)
                            if total > 0
                       else Multivector(-{0: 1, **-{mask: self.__d[mask] for mask -> block}-}-)
                            if total == 0
                       else Multivector(-{0: math.cos(value), **-{mask:math.sin(value)*self.__d[mask]/value for mask -> block}-}-)
                } => prod if isinstance(prod, Multivector) else Multivector(-{0: prod}-)
            }

            := __pos__(self) >: int | None {
                grade = None;
                for mask -> self.__d.keys() {
                    if grade =& None: grade = mask.bit_count();
                    elif mask.bit_count() != grade :=> None
                } => grade
            }

            := __truediv__(self, other: _Union[int, float, 'Multivector']) >: 'Multivector' {
                if isinstance(other, int | float) :=> Multivector(-{mask: value/other for mask, value -> self.__d.items()}-,
                    decomposition=self.__decomposition, sigma=self.__sigma);
                if !isinstance(other, Multivector) {
                    if isinstance(other, IMultivector): raise GAMismatchError("Cannot combine Multivectors from different GA instances");
                    => NotImplemented
                }
                => self*(other**(-1))
            }

            := __rtruediv__(self, other: int | float) >: 'Multivector' {
                if !isinstance(other, int | float) :=> NotImplemented;
                => other*(self**(-1))
            }

            := __format__(self, form: str) >: str :=> '<'+(''.join(('+' if value > 0 else '') + format(value, form) + ''.join(
                'e' + str(i+1).translate(_subscripts) for i -> range(mask.bit_length()) if (mask >> i) & 1)
                for mask, value -> self.__d.items()).removeprefix('+') if self.__d else format(0.0,form))+'>';

            := __str__(self) >: str :=> f'{self:g}'
        }

        ga.__Multivector = Multivector
    }

    @_overload; := __getitem__(self, n: int) >: IMultivector {}
    @_overload; := __getitem__(self, n: slice) >: tuple[IMultivector] {}

    := __getitem__(self, n){
        """
        Get the nth basis vector of the GA if n > 1, the unit scalar if n = 0
        and the zero Multivector if n < 0.
        """;
        if isinstance(n, int) :=> self.__Multivector(-{(1<<(n-1) if n > 0 else 0): 1.0}- if n >= 0 else -{}-);
        if !isinstance(n, slice) :=> NotImplemented;
        if n.stop =& None: raise ValueError('Cannot create an open-ended slice of GA; please specify a finite stop index.');
        step = n.step || 1;
        start = n.start || 0;
        => tuple(self[n] for n -> range(start, n.stop, step))
    }

    := __call__(self, multivector: IMultivector) >: IMultivector {
        """
        Convert any Multivector to a Multivector of this GA.
        """;
        => self.__Multivector(multivector._Multivector__d,
                              decomposition=multivector._Multivector__decomposition,
                              sigma=multivector._Multivector__sigma)
    }

    := __str__(self) >: str :=> f"GA<signature={getattr(self.signature, '__name__', repr(self.signature))}, epsilon_order={self.epsilon_order}>"
}